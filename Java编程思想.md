# Java 编程思想
## 第七章
### 7.5 组合继承之间的选择
（1）组合与继承都允许在新的类中放置子对象，组合是显式地这样做，继承是隐式的。
### 7.7.2 再论组合与继承
（1）应当慎用继承，在组合和继承之间做选择时，最清晰的判断方法就是问一问自己是否需要
从新类向基类向上转型，如果必须向上转型则是必要的，如果不是则需要好好考虑是否需要继承。

## 第八章 多态
（1）多态的作用是消除类型之间的耦合关系。  
（2）Java中的所有的方法都是通过动态绑定实现多态的，因为编译器事先不知道类型，只有在
运行时才可以确定。
### 8.2.1
（1）Java中除了static方法和final方法（private 属于final方法）之外，其他所有的方法都是后期绑定。  
（2）为什么要将某个方法声明为final呢？它可以防止其他人覆盖该方法。但是更重要的一点是：这样可以有效的  
”关闭“动态绑定，或者说告诉编译器不需要动态绑定，这样可以提高效率。但是大部分情况下，这样做不会对程序的  
整体性能有什么改观。所以，最好根据设计来决定是否使用final，而不是出于试图提高性能的目的来使用final。  
### 8.3.2 继承与清理
当基类拥有某个dispose（处置、清理）方法时，子类复写了该方法。销毁的顺序应该和初始化顺序相反，对于字段  
则意味着与声明的顺序相反（因为字段的初始化是按照声明的顺序进行的）。对于基类，应该首先对其子类进行清理然后才  
是基类（遵循C++中析构函数的形式）。因为子类的的清理可能会调用基类中的某些方法。所以需要使基类中的构件仍起到  
作用而不应该过早的销毁。

## 第九章 接口
恰当的原则应该是优先选择类而不是接口。从类开始，如果接口的必须性变得d非常明确，那么就进行重构。接口是一种重要  
的工具，但是它们容易被滥用。

## 第十章 内部类（篇幅较多，比较重要）
（1）非静态内部类会隐式持有外部类的引用。  
（2）拥有外部类对象之前是不可能创建内部类的，除非是静态内部类。  
（3）闭包（closure）是一个可调用的对象，它记了一些信息，这些信息来自于创建它的作用域。  
（4）局部内部类在方法外是不可见的，为什么仍然使用局部内部类而不是使用匿名内部类呢。唯一的理由是，我们需要一个已经  
命名的构造器或者需要重载构造器，而匿名内部类只能用于初始化。另外有一个理由就是需要不止一个该内部类对象。  

## 第十一章 持有对象  
（1）新程序中不应该使用过时的Vector、Hashtable和Stack。 

## 第十二章 通过异常处理错误
（1）Throwable对象可分为两种类型（指从Throwable继承而得到的类型）：
1.Error用来表示编译时和系统错误（除特殊情况外，一般不用关心）   
2.Exception 是可以被抛出的基本类型。Java程序员关心的类型通常是Exception。  其中异常又分为IOException 和RuntimeException  
（2）异常分类：
a.非检查异常：Error 和 RuntimeException 以及他们的子类。javac在编译时，不会提示和发现这样的异常，不要求在程序处理这些异常。
所以如果愿意，我们可以编写代码处理（使用try...catch...finally）这样的异常，也可以不处理。对于这些异常，我们应该修正代码，而
不是去通过异常处理器处理 。这样的异常发生的原因多半是代码写的有问题。如除0错误ArithmeticException，错误的强制类型转换错误
ClassCastException，数组索引越界ArrayIndexOutOfBoundsException，使用了空对象NullPointerException等等。  
b.检查异常：除了Error 和 RuntimeException的其它异常。javac强制要求程序员为这样的异常做预备处理工作（使用try...catch...finally或者throws）。  在方法中要么用try-catch语句捕获它并处理，要么用throws子句声明抛出它，否则编译不会通过。这样的异常一般是由程序的运行环境导致的。因为程序可能被运行
在各种未知的环境下，而程序员无法干预用户如何使用他编写的程序，于是程序员就应该为这样的异常时刻准备着。如SQLException,IOException,ClassNotFoundException 等。  

## 第十三章 字符串
讲述字符串的一些操作和常用方法，函数和正则表达式。

## 第十四章 类型信息
（1）运行时类型信息（Runtime Type Information 简称 RTTI）使得你可以在程序运行时发现和使用类型信息。  
（2）Java如何在运行时识别类和对象信息的，主要有2种方式：RTTI 和 反射。  
（3）所有类都是在第一次使用时动态加载到JVM的，因此Java程序在它运行之前并非被完全加载，其各个部分是在必需时才加载的。类加载器首先检查这个类的Class对象是否已经加载。如果没有加载，默认的类加载器就会根据类名查找.class文件。在这个类的字节码被加载时，它们会接受验证，以确保其没有被破坏，并且不包含不良的Java代码（这是Java中用于安全防范目的的措施之一）。一旦某个类的Class对象被载入内存，它就会被用来创建这个类的所有对象。   
### 14.7 动态代理  
了解下代理模式和动态代理。

## 第十五章 泛型



