# Java 编程思想
## 第七章
### 7.5 组合继承之间的选择
（1）组合与继承都允许在新的类中放置子对象，组合是显式地这样做，继承是隐式的。
### 7.7.2 再论组合与继承
（1）应当慎用继承，在组合和继承之间做选择时，最清晰的判断方法就是问一问自己是否需要
从新类向基类向上转型，如果必须向上转型则是必要的，如果不是则需要好好考虑是否需要继承。

## 第八章 多态
（1）多态的作用是消除类型之间的耦合关系。  
（2）Java中的所有的方法都是通过动态绑定实现多态的，因为编译器事先不知道类型，只有在
运行时才可以确定。
### 8.2.1
（1）Java中除了static方法和final方法（private 属于final方法）之外，其他所有的方法都是后期绑定。  
（2）为什么要将某个方法声明为final呢？它可以防止其他人覆盖该方法。但是更重要的一点是：这样可以有效的  
”关闭“动态绑定，或者说告诉编译器不需要动态绑定，这样可以提高效率。但是大部分情况下，这样做不会对程序的  
整体性能有什么改观。所以，最好根据设计来决定是否使用final，而不是出于试图提高性能的目的来使用final。  
### 8.3.2 继承与清理
当基类拥有某个dispose（处置、清理）方法时，子类复写了该方法。销毁的顺序应该和初始化顺序相反，对于字段  
则意味着与声明的顺序相反（因为字段的初始化是按照声明的顺序进行的）。对于基类，应该首先对其子类进行清理然后才  
是基类（遵循C++中析构函数的形式）。因为子类的的清理可能会调用基类中的某些方法。所以需要使基类中的构件仍起到  
作用而不应该过早的销毁。

## 第九章 接口
恰当的原则应该是优先选择类而不是接口。从类开始，如果接口的必须性变得d非常明确，那么就进行重构。接口是一种重要  
的工具，但是它们容易被滥用。

## 第十章 内部类（篇幅较多，比较重要）
（1）非静态内部类会隐式持有外部类的引用。  
（2）拥有外部类对象之前是不可能创建内部类的，除非是静态内部类。  
（3）闭包（closure）是一个可调用的对象，它记了一些信息，这些信息来自于创建它的作用域。  
（4）局部内部类在方法外是不可见的，为什么仍然使用局部内部类而不是使用匿名内部类呢。唯一的理由是，我们需要一个已经  
命名的构造器或者需要重载构造器，而匿名内部类只能用于初始化。另外有一个理由就是需要不止一个该内部类对象。  

## 第十一章 持有对象  
（1）新程序中不应该使用过时的Vector、Hashtable和Stack。 

## 第十二章 通过异常处理错误
（1）Throwable对象可分为两种类型（指从Throwable继承而得到的类型）：
1.Error用来表示编译时和系统错误（除特殊情况外，一般不用关心）   
2.Exception 是可以被抛出的基本类型。Java程序员关心的类型通常是Exception。  其中异常又分为IOException 和RuntimeException  
（2）异常分类：
a.非检查异常：Error 和 RuntimeException 以及他们的子类。javac在编译时，不会提示和发现这样的异常，不要求在程序处理这些异常。
所以如果愿意，我们可以编写代码处理（使用try...catch...finally）这样的异常，也可以不处理。对于这些异常，我们应该修正代码，而
不是去通过异常处理器处理 。这样的异常发生的原因多半是代码写的有问题。如除0错误ArithmeticException，错误的强制类型转换错误
ClassCastException，数组索引越界ArrayIndexOutOfBoundsException，使用了空对象NullPointerException等等。  
b.检查异常：除了Error 和 RuntimeException的其它异常。javac强制要求程序员为这样的异常做预备处理工作（使用try...catch...finally或者throws）。  在方法中要么用try-catch语句捕获它并处理，要么用throws子句声明抛出它，否则编译不会通过。这样的异常一般是由程序的运行环境导致的。因为程序可能被运行
在各种未知的环境下，而程序员无法干预用户如何使用他编写的程序，于是程序员就应该为这样的异常时刻准备着。如SQLException,IOException,ClassNotFoundException 等。  

## 第十三章 字符串
讲述字符串的一些操作和常用方法，函数和正则表达式。

## 第十四章 类型信息
（1）运行时类型信息（Runtime Type Information 简称 RTTI）使得你可以在程序运行时发现和使用类型信息。  
（2）Java如何在运行时识别类和对象信息的，主要有2种方式：RTTI 和 反射。  
（3）所有类都是在第一次使用时动态加载到JVM的，因此Java程序在它运行之前并非被完全加载，其各个部分是在必需时才加载的。类加载器首先检查这个类的Class对象是否已经加载。如果没有加载，默认的类加载器就会根据类名查找.class文件。在这个类的字节码被加载时，它们会接受验证，以确保其没有被破坏，并且不包含不良的Java代码（这是Java中用于安全防范目的的措施之一）。一旦某个类的Class对象被载入内存，它就会被用来创建这个类的所有对象。   
### 14.7 动态代理  
了解下代理模式和动态代理。

## 第十五章 泛型
要求点前提：一般的类和方法，只能使用具体的类型：要么是基本类型，要么是自定义的类。如果要编写可以应用于多种类型的代码，这种刻板的限制对代码的束缚就很很大。  

## 第十六章 数组
数组为何支持随机访问：
（1）数组占用的内存空间是连续的；
（2）数组中都为同一类型的元素。
为什么数组访问比较快：
因为数组在内存空间中是连续的，所以CPU在读取时，可以对数组进行“预读”。什么是预读呢？CPU在从内存中加载数据时，会先把读取到的数组加载到CPU的缓存中。而CPU每次从内存中读取数据，并不是只读取那个特定的要访问的地址，而是读取一个数据块，并保存到CPU缓存中，然后下次访问内存数据的时候就会先从CPU缓存开始查找，如果找到就不需要再从内存中取，这样就实现了比直接访问内存更高效的访问机制（这样做的原因是因为，CPU处理数据的速度高于从内存中读取数据的速度）。
ArrayList 其实也是基于数组实现的，内部包含一个动态扩容的数组，每次add都会检查是否需要扩容，get的时候实际上也是通过内部的数组获取，因为中间多了一层操作，所以数组还是比ArrayList get获取要快。

## 第十七章 容器的深入研究
### 17.12 持有引用
HashMap原理讲解比较好的文章：  
https://zhuanlan.zhihu.com/p/28501879   
https://www.jianshu.com/p/3bf097f4cf0a   

HashMap中推荐使用entrySet方式遍历Map类集合KV而不是keySet方式遍历
https://blog.csdn.net/qq_35542218/article/details/83935017

## 第十八章 Java I/O 系统
## 第十九章 枚举类型
## 第二十章 注解
定义：注解也被成为元数据，为我们在代码中添加信息提供了一种形式化的方法，使我们可以在稍后某个时刻非常方便地使用这些数据。
## 第二十一章 并发
(1)线程状态：创建-->就绪-->运行-->阻塞-->死亡
(2)一个任务可以多次获得对象的锁。如果一个方法在同一个对象调用了一个个方法，后者又调用了同一对象上的另一个方法，就会发生这样的情况。
JVM负责跟踪对象被加锁的次数。如果一个对象被解锁（即锁被完全释放），其计数变成0。在任务第一次给对象加锁的时候计数变为1。每当相同的任务
在这个对象上获得锁时，计数都会递增。显然，只有首先获得锁的任务才能允许继续获得多个锁。每当任务离开一个synchronized方法，计数递减，当
计数为0时，锁完全释放。此时别的任务就可以使用此资源。
针对每一个类也有一个锁（作为类Class对象的一部分），所以synchronized的static方法可以在类的范围防止对static数据并发地访问。
（3）volitale关键字确保了应用的可视性。如果你把一个域声明为volitale的，那么只要对这个域产生了写操作，那么所有的读操作就都可以看到这个修改。
即使使用了本地缓存。volitale域会被立即写到主存中，而读操作就发生在主存中。
